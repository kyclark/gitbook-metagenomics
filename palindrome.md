# I, Palindrome, I

Here's a common example used to teach "strings," which in CS-talk means a list of characters.  We're going to write a program that finds all the palindromes (words spelled the same forwards and backwards) in a list of words.  By default, we're going to read the dictionary that's almost universally in the same place on every Unix system.  The user can provide a different word list, if they like.  Here's our first version:

```
$ ./palindrome1.pl6 -h
Usage:
  ./palindrome1.pl6 [<file>]
$ cat -n palindrome1.pl6
     1	#!/usr/bin/env perl6
     2
     3	sub MAIN (Str $file='/usr/share/dict/words') {
     4	    die "$file not a file" unless $file.IO.f;
     5
     6	    for $file.IO.lines -> $word {
     7	        my $lc  = $word.lc;
     8	        my $rev = $lc.comb.reverse.join;
     9
    10	        if $lc eq $rev {
    11	            put $word;
    12	        }
    13	    }
    14	}
```

We will want to lowercase the words because "Mom" is not equal to "moM," so line 7 copies the ```$word``` into ```$lc```.  To find the reverse of the word, we unfortunately cannot use ```reverse``` (https://docs.perl6.org/routine/reverse) because that is a list function:

```
$ perl6
> (1..10).reverse
(10 9 8 7 6 5 4 3 2 1)
> "I like cake".reverse
(I like cake)
> 42.reverse
(42)
> <I like cake>.reverse
(cake like I)
```

A list like that generated by ```1..10``` can easily be reversed, but when we apply ```reverse``` to the string "I like cake," it becomes like a list with one element ("I like cake"), which, when reversed, is the same thing.  That's why ```42.reverse``` is just "42" and not "24."  If we use the ```<>``` quoting operator to turn "I like cake" into a list of three words, then we can get those back in reverse order, but that is not the same thing as getting back "ekac ekil I."

So, how can we turn a "string" into a list of characters?  We could ```split``` on the empty string:

```
> "I like cake".split('')
( I   l i k e   c a k e )
```

But it turns out there's an operator to do exactly what we want called ```comb```:

```
> "I like cake".comb
(I   l i k e   c a k e)
```

Now reverse it:

```
> "I like cake".comb.reverse
(e k a c   e k i l   I)
```

And put the letters back together with ```join```:

```
> "I like cake".comb.reverse.join
ekac ekil I
```

And that's what's happening on line 8:

```
my $rev = $lc.comb.reverse.join;
```

If the forward and reverse are the same, print the word.  (Be sure to use ```eq``` for string equivalence and not ```==``` for numerical.  Try ```===``` to understand the error you get.)

```
if $lc eq $rev {
    put $word;
}
```

Ask yourself, what do you get if you make this mistake?  If you don't know, try it and see.

```
if $lc = $rev { # very bad code
    put $word;
}
```

Now let's run our script, and see what we get:

```
$ ./palindrome1.pl6 | head -5
A
a
aa
aba
Abba
```

Right away, I don't like the fact that we have single letters showing up, so let's skip those.  While we're at it, I'm going to shorten up the comparison:

```
$ cat -n palindrome2.pl6
     1	#!/usr/bin/env perl6
     2
     3	sub MAIN (Str $file='/usr/share/dict/words') {
     4	    die "$file not a file" unless $file.IO.f;
     5
     6	    for $file.IO.lines -> $word {
     7	        next if $word.chars == 1;
     8	        if $word.lc eq $word.lc.comb.reverse.join {
     9	            put $word;
    10	        }
    11	    }
    12	}
```

Line 7 is the new bit of logic I added; otherwise, I just got rid of the ```$lc``` and ```$rev``` variables and directly test the conditions.

Ask yourself what is the result if you change the ```==``` (numerical comparison) on line 7 to ```=``` (assignment)?  In this case, you'd get this error:

```
Cannot modify an immutable Int
  in sub MAIN at ./palindrome2.pl6 line 7
  in block <unit> at ./palindrome2.pl6 line 3
```

You're not allowed to change the number of characters in the ```$word``` by assigning a value to it, which is as it should be!  Let's test our script:

```
$ ./palindrome2.pl6 | head -5
aa
aba
Abba
acca
Ada
```

It works and no longer emits single-letter words, but something that bothers me about the above code is that I'm breaking the DRY (Don't Repeat Yourself) code by executing ```lc``` twice.  What if I have that done to the words as they come from ```lines```?  We saw this a bit in the previous chapter with uppercasing a file using a ```map``` statement to apply a function (```lc```) to every member of a list (the words from ```lines```):

```
$ cat -n palindrome3.pl6
     1	#!/usr/bin/env perl6
     2
     3	sub MAIN (Str $file='/usr/share/dict/words') {
     4	    die "$file not a file" unless $file.IO.f;
     5
     6	    for $file.IO.lines.map(*.lc) -> $word {
     7	        next if $word.chars == 1;
     8	        if $word eq $word.comb.reverse.join {
     9	            put $word;
    10	        }
    11	    }
    12	}
```

Let's look at some more examples of ```map```:

```
$ perl6
> <We will, we will, rock you>.map(*.tc)
(We Will, We Will, Rock You)
> (1..10).map(* / 2)
(0.5 1 1.5 2 2.5 3 3.5 4 4.5 5)
> <My cat's breath smells like cat food>.map(*.chars)
(2 5 6 6 4 3 4)
> (1..10).map(*.is-prime)
(False True True False True False True False False False)
```

The ```*``` is the list element at the time and can be called "whatever" or "the thing" or "the topic."  The ```*``` creates block automatically, but you could also write the block explicitly and use the regular ```$_``` for the topic variable.

```
> (1.4, 3.6, 8.1, 2.3).map({$_.floor})
(1 3 8 2)
> (1..10).map({$_**2})
(1 4 9 16 25 36 49 64 81 100)
```

Just because, I want to shorten up the code a bit more by using ```grep``` to filter the words to those of a minimum length:

```
$ cat -n palindrome4.pl6
     1	#!/usr/bin/env perl6
     2
     3	sub MAIN (Str $file='/usr/share/dict/words') {
     4	    die "$file not a file" unless $file.IO.f;
     5
     6	    for $file.IO.lines.grep(*.chars>1).map(*.lc) -> $word {
     7	        if $word eq $word.comb.reverse.join {
     8	            put $word;
     9	        }
    10	    }
    11	}
```

Finally, I would like to keep track of the number of found words, so I'll add a counter and a ```printf``` statement to make pretty output:

```
$ cat -n palindrome5.pl6
     1	#!/usr/bin/env perl6
     2
     3	sub MAIN (Str $file='/usr/share/dict/words') {
     4	    die "$file not a file" unless $file.IO.f;
     5
     6	    my $i = 0;
     7	    for $file.IO.lines.grep(*.chars>1).map(*.lc) -> $word {
     8	        if $word eq $word.comb.reverse.join {
     9	            printf "%3d: %s\n", ++$i, $word;
    10	        }
    11	    }
    12	}
```

The only tricky thing to point out here is the ```++$i``` which increments the variable *before* taking the value.  If I did ```$i++```, then it would first print "0" (the initial value) and after would bump it to "1."

What if we wanted to run this on any text file, not just a simple list of words?  

```
$ cat -n palindrome6.pl6
     1	#!/usr/bin/env perl6
     2
     3	sub MAIN (Str $file='/usr/share/dict/words') {
     4	    die "$file not a file" unless $file.IO.f;
     5
     6	    my $i = 0;
     7	    for $file.IO.lines -> $line {
     8	        for $line.words.grep(*.chars>1).map(*.lc) -> $word {
     9	            if $word eq $word.comb.reverse.join {
    10	                printf "%3d: %s\n", ++$i, $word;
    11	            }
    12	        }
    13	    }
    14	}
$ wget http://www.usconstitution.net/const.txt
$ ./palindrome6.pl6 const.txt
  1: ------------------------------
  2: 11
  3: noon
  4: noon
  5: noon
  6: 22
```

Running that on the text of the US Constitution, we find only a few palindromes. 