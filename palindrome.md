# Palindrome

Here's a common example used to teach "strings," which in CS-talk means a list of characters.  We're going to write a program that finds all the palindromes (words spelled the same forwards and backwards) in a list of words.  By default, we're going to read the dictionary that's almost universally in the same place on every Unix system.  The user can provide a different word list, if they like.  Here's our first version:

```
$ ./palindrome1.pl6 -h
Usage:
  ./palindrome1.pl6 [<file>]
$ cat -n palindrome1.pl6
     1	#!/usr/bin/env perl6
     2
     3	sub MAIN (Str $file='/usr/share/dict/words') {
     4	    die "$file not a file" unless $file.IO.f;
     5
     6	    for $file.IO.lines -> $word {
     7	        my $lc  = $word.lc;
     8	        my $rev = $lc.comb.reverse.join;
     9
    10	        if $lc eq $rev {
    11	            put $word;
    12	        }
    13	    }
    14	}
```

We will want to lowercase the words because "Mom" is not equal to "moM," so line 7 copies the ```$word``` into ```$lc```.  To find the reverse of the word, we unfortunately cannot use ```reverse``` (https://docs.perl6.org/routine/reverse) because that is a list function:

```
$ perl6
> (1..10).reverse
(10 9 8 7 6 5 4 3 2 1)
> "I like cake".reverse
(I like cake)
> 42.reverse
(42)
> <I like cake>.reverse
(cake like I)
```

A list like that generated by ```1..10``` can easily be reversed, but when we apply ```reverse``` to the string "I like cake," it becomes like a list with one element ("I like cake"), which, when reversed, is the same thing.  That's why ```42.reverse``` is just "42" and not "24."  If we use the ```<>``` quoting operator to turn "I like cake" into a list of three words, then we can get those back in reverse order, but that is not the same thing as getting back "ekac ekil I."

So, how can we turn a "string" into a list of characters?  We could ```split``` on the empty string:

```
> "I like cake".split('')
( I   l i k e   c a k e )
```

But it turns out there's an operator to do exactly what we want called ```comb```:

```
> "I like cake".comb
(I   l i k e   c a k e)
```

Now reverse it:

```
> "I like cake".comb.reverse
(e k a c   e k i l   I)
```

And put the letters back together with ```join```:

```
> "I like cake".comb.reverse.join
ekac ekil I
```

And that's what's happening on line 8:

```
my $rev = $lc.comb.reverse.join;
```

If the forward and reverse are the same, print the word.  (Be sure to use ```eq``` for string equivalence and not ```==``` for numerical.  Try ```===``` to understand the error you get.)

```
if $lc eq $rev {
    put $word;
}
```

Ask yourself, what do you get if you make this mistake?  If you don't know, try it and see.

```
if $lc = $rev { # very bad code
    put $word;
}
```

Now let's run our script, and see what we get:

```
$ ./palindrome1.pl6 | head -5
A
a
aa
aba
Abba
```

Right away, I don't like the fact that we have single letters showing up, so let's skip those.  While we're at it, I'm going to shorten up the comparison:

```
$ cat -n palindrome2.pl6
     1	#!/usr/bin/env perl6
     2
     3	sub MAIN (Str $file='/usr/share/dict/words') {
     4	    die "$file not a file" unless $file.IO.f;
     5
     6	    for $file.IO.lines -> $word {
     7	        next if $word.chars == 1;
     8	        if $word.lc eq $word.lc.comb.reverse.join {
     9	            put $word;
    10	        }
    11	    }
    12	}
```

Line 7 is the new bit of logic I added; otherwise, I just got rid of the ```$lc``` and ```$rev``` variables and directly test the conditions.

Ask yourself what is the result if you change the ```==``` (numerical comparison) on line 7 to ```=``` (assignment)?  In this case, you'd get this error:

```
Cannot modify an immutable Int
  in sub MAIN at ./palindrome2.pl6 line 7
  in block <unit> at ./palindrome2.pl6 line 3
```

You're not allowed to change the number of characters in the ```$word``` by assigning a value to it, which is as it should be!  Let's test our script:

```
$ ./palindrome2.pl6 | head -5
aa
aba
Abba
acca
Ada
```

It works and no longer emits single-letter words, but something that bothers me about the above code is that I'm breaking the DRY (Don't Repeat Yourself) code by executing ```lc``` twice.  What if I have that done to the words as they come from ```lines```?  We 